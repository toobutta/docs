---
title: "CI/CD Pipeline"
description: "GitHub Actions workflows for automated testing and deployment"
---

## Overview

The Evoteli uses GitHub Actions for continuous integration and deployment. This includes automated testing, linting, security scanning, Docker image building, and deployment to staging/production environments.

## Workflow Structure

```
.github/
└── workflows/
    ├── api-gateway-ci.yml          # API Gateway CI/CD
    ├── stream-processor-ci.yml     # Stream Processor CI/CD
    ├── edge-device-ci.yml          # Edge Device CI/CD
    ├── database-migrations.yml     # Database migration workflow
    └── security-scan.yml           # Security vulnerability scanning
```

## API Gateway CI/CD

### .github/workflows/api-gateway-ci.yml

```yaml
name: API Gateway CI/CD

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'services/api-gateway/**'
      - '.github/workflows/api-gateway-ci.yml'
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'services/api-gateway/**'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/api-gateway

jobs:
  # ========================================
  # LINT & TEST
  # ========================================

  lint-and-test:
    name: Lint and Test
    runs-on: ubuntu-latest

    strategy:
      matrix:
        python-version: ["3.11"]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache Poetry dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pypoetry
            services/api-gateway/.venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('services/api-gateway/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Install dependencies
        working-directory: services/api-gateway
        run: |
          poetry config virtualenvs.in-project true
          poetry install --no-interaction

      - name: Run Black (code formatter)
        working-directory: services/api-gateway
        run: poetry run black --check app/

      - name: Run isort (import sorter)
        working-directory: services/api-gateway
        run: poetry run isort --check-only app/

      - name: Run MyPy (type checker)
        working-directory: services/api-gateway
        run: poetry run mypy app/

      - name: Run Pytest (unit tests)
        working-directory: services/api-gateway
        run: |
          poetry run pytest --cov=app --cov-report=xml --cov-report=term

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: services/api-gateway/coverage.xml
          flags: api-gateway
          name: api-gateway-coverage

  # ========================================
  # INTEGRATION TESTS
  # ========================================

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: lint-and-test

    services:
      clickhouse:
        image: clickhouse/clickhouse-server:23.8
        ports:
          - 8123:8123
          - 9000:9000
        options: >-
          --health-cmd "wget --spider -q localhost:8123/ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      postgres:
        image: postgis/postgis:15-3.3
        env:
          POSTGRES_USER: geointel
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: geointel_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      valkey:
        image: valkey/valkey:7.2
        ports:
          - 6379:6379
        options: >-
          --health-cmd "valkey-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install dependencies
        working-directory: services/api-gateway
        run: poetry install --no-interaction

      - name: Run database migrations
        working-directory: services/api-gateway
        env:
          CLICKHOUSE_HOST: localhost
          CLICKHOUSE_PORT: 8123
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: geointel
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: geointel_test
        run: |
          # Run ClickHouse migrations
          for file in ../../migrations/clickhouse/*.sql; do
            curl -X POST "http://localhost:8123/?user=default" --data-binary @"$file"
          done

          # Run PostGIS migrations
          export PGPASSWORD=test_password
          for file in ../../migrations/postgis/*.sql; do
            psql -h localhost -U geointel -d geointel_test -f "$file"
          done

      - name: Run integration tests
        working-directory: services/api-gateway
        env:
          CLICKHOUSE_HOST: localhost
          CLICKHOUSE_PORT: 8123
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: geointel
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: geointel_test
          VALKEY_HOST: localhost
          VALKEY_PORT: 6379
        run: poetry run pytest tests/test_integration.py -v

  # ========================================
  # BUILD DOCKER IMAGE
  # ========================================

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [lint-and-test, integration-tests]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')

    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: services/api-gateway
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ========================================
  # DEPLOY TO STAGING
  # ========================================

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://api-staging.evoteli.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        env:
          KUBECONFIG: ${{ secrets.STAGING_KUBECONFIG }}
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

          # Update deployment
          kubectl set image deployment/api-gateway \
            api-gateway=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop-${{ github.sha }} \
            --namespace=geointel-staging

          # Wait for rollout
          kubectl rollout status deployment/api-gateway --namespace=geointel-staging

      - name: Run smoke tests
        run: |
          # Wait for deployment to be ready
          sleep 30

          # Test health endpoint
          curl -f https://api-staging.evoteli.com/health || exit 1

          echo "Smoke tests passed"

  # ========================================
  # DEPLOY TO PRODUCTION
  # ========================================

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://api.evoteli.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to production
        env:
          KUBECONFIG: ${{ secrets.PRODUCTION_KUBECONFIG }}
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

          # Update deployment (blue-green deployment)
          kubectl set image deployment/api-gateway \
            api-gateway=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main-${{ github.sha }} \
            --namespace=geointel-production

          # Wait for rollout
          kubectl rollout status deployment/api-gateway --namespace=geointel-production

      - name: Run production smoke tests
        run: |
          # Wait for deployment
          sleep 30

          # Test health endpoint
          curl -f https://api.evoteli.com/health || exit 1

          # Test authenticated endpoint (requires test token)
          # curl -f -H "Authorization: Bearer ${{ secrets.TEST_TOKEN }}" \
          #   https://api.evoteli.com/v1/signals:query \
          #   -d '{"site_id":"test","metrics":["occupancy"],...}' || exit 1

          echo "Production smoke tests passed"

      - name: Notify Slack
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": "Production deployment ${{ job.status }}: ${{ github.ref }} @ ${{ github.sha }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment ${{ job.status }}*\n\nBranch: `${{ github.ref }}`\nCommit: `${{ github.sha }}`\nActor: ${{ github.actor }}"
                  }
                }
              ]
            }
```

## Database Migrations Workflow

### .github/workflows/database-migrations.yml

```yaml
name: Database Migrations

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'migrations/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to run migrations'
        required: true
        type: choice
        options:
          - staging
          - production

jobs:
  validate-migrations:
    name: Validate Migrations
    runs-on: ubuntu-latest

    services:
      clickhouse:
        image: clickhouse/clickhouse-server:23.8
        ports:
          - 8123:8123

      postgres:
        image: postgis/postgis:15-3.3
        env:
          POSTGRES_USER: geointel
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Test ClickHouse migrations
        run: |
          for file in migrations/clickhouse/*.sql; do
            echo "Testing $file..."
            curl -X POST "http://localhost:8123/?user=default" \
              --data-binary @"$file" || exit 1
          done

      - name: Test PostGIS migrations
        env:
          PGPASSWORD: test_password
        run: |
          for file in migrations/postgis/*.sql; do
            echo "Testing $file..."
            psql -h localhost -U geointel -d test_db -f "$file" || exit 1
          done

      - name: Verify schema
        env:
          PGPASSWORD: test_password
        run: |
          # Check ClickHouse tables
          curl "http://localhost:8123/?query=SHOW+TABLES+FROM+geointel"

          # Check PostGIS tables
          psql -h localhost -U geointel -d test_db -c "\dt"

  run-migrations-staging:
    name: Run Migrations (Staging)
    runs-on: ubuntu-latest
    needs: validate-migrations
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run ClickHouse migrations
        env:
          CLICKHOUSE_HOST: ${{ secrets.STAGING_CLICKHOUSE_HOST }}
          CLICKHOUSE_USER: ${{ secrets.STAGING_CLICKHOUSE_USER }}
          CLICKHOUSE_PASSWORD: ${{ secrets.STAGING_CLICKHOUSE_PASSWORD }}
        run: |
          for file in migrations/clickhouse/*.sql; do
            echo "Running $file on staging..."
            curl -X POST "http://${CLICKHOUSE_HOST}:8123/?user=${CLICKHOUSE_USER}&password=${CLICKHOUSE_PASSWORD}" \
              --data-binary @"$file"
          done

      - name: Run PostGIS migrations
        env:
          PGHOST: ${{ secrets.STAGING_POSTGRES_HOST }}
          PGUSER: ${{ secrets.STAGING_POSTGRES_USER }}
          PGPASSWORD: ${{ secrets.STAGING_POSTGRES_PASSWORD }}
          PGDATABASE: geointel
        run: |
          for file in migrations/postgis/*.sql; do
            echo "Running $file on staging..."
            psql -f "$file"
          done

  run-migrations-production:
    name: Run Migrations (Production)
    runs-on: ubuntu-latest
    needs: validate-migrations
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Backup databases
        env:
          CLICKHOUSE_HOST: ${{ secrets.PRODUCTION_CLICKHOUSE_HOST }}
          POSTGRES_HOST: ${{ secrets.PRODUCTION_POSTGRES_HOST }}
        run: |
          # Backup ClickHouse (snapshot)
          # TODO: Implement backup strategy

          # Backup PostgreSQL
          # TODO: Implement pg_dump backup

          echo "Backups completed"

      - name: Run ClickHouse migrations
        env:
          CLICKHOUSE_HOST: ${{ secrets.PRODUCTION_CLICKHOUSE_HOST }}
          CLICKHOUSE_USER: ${{ secrets.PRODUCTION_CLICKHOUSE_USER }}
          CLICKHOUSE_PASSWORD: ${{ secrets.PRODUCTION_CLICKHOUSE_PASSWORD }}
        run: |
          for file in migrations/clickhouse/*.sql; do
            echo "Running $file on production..."
            curl -X POST "http://${CLICKHOUSE_HOST}:8123/?user=${CLICKHOUSE_USER}&password=${CLICKHOUSE_PASSWORD}" \
              --data-binary @"$file"
          done

      - name: Run PostGIS migrations
        env:
          PGHOST: ${{ secrets.PRODUCTION_POSTGRES_HOST }}
          PGUSER: ${{ secrets.PRODUCTION_POSTGRES_USER }}
          PGPASSWORD: ${{ secrets.PRODUCTION_POSTGRES_PASSWORD }}
          PGDATABASE: geointel
        run: |
          for file in migrations/postgis/*.sql; do
            echo "Running $file on production..."
            psql -f "$file"
          done
```

## Security Scanning Workflow

### .github/workflows/security-scan.yml

```yaml
name: Security Scanning

on:
  push:
    branches:
      - main
      - develop
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  dependency-scan:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: 'services/api-gateway'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  docker-scan:
    name: Docker Image Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker image
        working-directory: services/api-gateway
        run: docker build -t api-gateway:test .

      - name: Run Trivy container scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'api-gateway:test'
          format: 'sarif'
          output: 'trivy-container-results.sarif'

      - name: Upload container scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-container-results.sarif'

  secrets-scan:
    name: Secrets Scanning
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## GitHub Secrets Configuration

Configure the following secrets in your GitHub repository settings:

### Staging Environment

- `STAGING_KUBECONFIG` - Kubernetes config for staging cluster
- `STAGING_CLICKHOUSE_HOST` - ClickHouse host
- `STAGING_CLICKHOUSE_USER` - ClickHouse user
- `STAGING_CLICKHOUSE_PASSWORD` - ClickHouse password
- `STAGING_POSTGRES_HOST` - PostgreSQL host
- `STAGING_POSTGRES_USER` - PostgreSQL user
- `STAGING_POSTGRES_PASSWORD` - PostgreSQL password

### Production Environment

- `PRODUCTION_KUBECONFIG` - Kubernetes config for production cluster
- `PRODUCTION_CLICKHOUSE_HOST` - ClickHouse host
- `PRODUCTION_CLICKHOUSE_USER` - ClickHouse user
- `PRODUCTION_CLICKHOUSE_PASSWORD` - ClickHouse password
- `PRODUCTION_POSTGRES_HOST` - PostgreSQL host
- `PRODUCTION_POSTGRES_USER` - PostgreSQL user
- `PRODUCTION_POSTGRES_PASSWORD` - PostgreSQL password
- `SLACK_WEBHOOK_URL` - Slack webhook for notifications

## Branch Protection Rules

Configure branch protection for `main` and `develop` branches:

### Main Branch (Production)

- ✅ Require pull request reviews (2 approvals)
- ✅ Require status checks to pass (all CI jobs)
- ✅ Require branches to be up to date
- ✅ Require conversation resolution
- ✅ Require signed commits
- ✅ Include administrators
- ✅ Restrict who can push (only release managers)

### Develop Branch (Staging)

- ✅ Require pull request reviews (1 approval)
- ✅ Require status checks to pass
- ✅ Require branches to be up to date
- ✅ Allow force pushes (for hotfixes)

## Deployment Strategy

### Blue-Green Deployment

1. **Deploy new version (green)** to separate pods
2. **Run health checks** on green deployment
3. **Switch traffic** from blue to green
4. **Monitor metrics** for 10 minutes
5. **Keep blue running** for rollback capability
6. **Terminate blue** after 1 hour if green is stable

### Rollback Procedure

```bash
# Rollback to previous version
kubectl rollout undo deployment/api-gateway --namespace=geointel-production

# Rollback to specific revision
kubectl rollout undo deployment/api-gateway --to-revision=2 --namespace=geointel-production

# Check rollout status
kubectl rollout status deployment/api-gateway --namespace=geointel-production
```

## Monitoring CI/CD

### GitHub Actions Dashboard

Monitor workflow runs at:
`https://github.com/evoteli/geo-intelligence-platform/actions`

### Metrics to Track

- **Build Duration:** Target <5 minutes
- **Test Success Rate:** Target >99%
- **Deployment Frequency:** Target 5-10/day (staging), 2-5/week (production)
- **Mean Time to Recovery (MTTR):** Target <15 minutes
- **Change Failure Rate:** Target <5%

## Next Steps

<CardGroup cols={2}>
  <Card title="Docker Compose" icon="docker" href="/deployment/docker-compose">
    Set up local development environment
  </Card>
  <Card title="Kubernetes Deployment" icon="cubes" href="/deployment/kubernetes">
    Deploy to production cluster
  </Card>
  <Card title="Observability" icon="chart-mixed" href="/deployment/observability">
    Monitor deployments with Prometheus
  </Card>
  <Card title="API Documentation" icon="book" href="/api-reference/introduction">
    Explore the API reference
  </Card>
</CardGroup>
